<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
//#region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';
import useTransformMultiControl              from '../_lib/useTransformMultiControl.js';
import GltfUtil, { Gltf2 }              from '../_lib/misc/GltfUtil.js';
import Util                             from '../_lib/misc/Util.js';

import { Armature, Pose, TranMatrixSkin, BoneMap,
    IKTarget, IKChain, limbSolver
} from '../../src/index';

import MatrixSkinMaterial               from '../_lib/customSkinning/MatrixSkinMaterial.js';
//#endregion

//#region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = {
    gizmo : useTransformMultiControl( App, 2 ).useAxes( 0.1 ),
};

Ref.gizmo.onMove = ( i, p )=>{
    // switch( i ){
    //     case 0:
    //         Ref.rig.setTargetPos( 'arm_l', p );
    //         break;
    //     case 1:
    //         Ref.rig.setPolePos( 'arm_l', p );
    //         break;
    // }

    // Ref.rig.runSolvers();
    // Ref.char.updateSkin( Ref.rig.pose );
};

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 0, 20, 3, [0,0.8,0] );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.char = await Character.fetch( '/prototypes/_res/models/nabba/nabba.gltf' );
    App.scene.add( Ref.char.mesh );

    Ref.rig = new BipedalRig( Ref.char.arm );

    Ref.rig.updateTargetsFromPose();
    Ref.rig.debugTargets()

    const pos = Ref.rig.getTargetPos( 'arm_l' );
    Ref.gizmo.setPos( 0, pos );
    Ref.gizmo.setPos( 1, [ pos[0]-0.2, pos[1], pos[2]-0.4 ] );

    // Ref.rig.runSolvers();
    // Ref.char.updateSkin( Ref.rig.pose );


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.createRenderLoop( onPreRender ).start();
    App.renderLoop( onPreRender );
});

function onPreRender( dt, et ){

}

class Character{
    static async fetch( url ){
        const gltf = await Gltf2.fetch( url);
        return new Character( gltf );
    }

    constructor( gltf ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Armature
        this.arm = GltfUtil.parseArmature( gltf );
        this.arm.useSkin( TranMatrixSkin );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Mesh
        const geo  = GltfUtil.loadGeoBuffers( gltf )[0];
        const mat  = MatrixSkinMaterial( 'cyan', this.arm.skin );
        this.mesh  = new THREE.Mesh( geo, mat );
    }

    setPos( p ){ this.mesh.position.fromArray( p ); return this; }

    updateSkin( pose ){
        this.arm.skin.updateFromPose( pose );
    }
}


class RigItemX{
    constructor( bones, targetBoneIdx=-1 ){
        this.chain      = new IKChain( bones );
        this.target     = new IKTarget();
        this.targetIdx  = targetBoneIdx;
        this.solver     = limbSolver;
    }
}

class BipedalRigX{
    items = new Map();
    pose  = null;
    constructor( arm ){
        this.pose = arm.newPose();

        const bMap = new BoneMap( arm );

        const ri = new RigItem( 
            bMap.getBones( ['upperarm_l','forearm_l'] ),
            bMap.getBoneIndex( 'hand_l' )
        );

        // ri.chain.updateRootFromPose( arm.bindPose );
        // ri.chain.debug( Debug );

        this.items.set( 'arm_l', ri );
    }

    updateTargetsFromPose(){
        for( const i of this.items.values() ){
            i.target.setPos( this.pose.bones[ i.targetIdx ].world.pos );
        }
    }

    getTargetPos( name ){
        const ri = this.items.get( name );
        return ( ri )? ri.target.pos : [0,0,0];
    }

    setTargetPos( name, pos ){
        const ri = this.items.get( name );
        ri?.target.setPos( pos );
    }

    setPolePos( name, pos ){
        const ri = this.items.get( name );
        ri?.target.setPolePos( pos );
    }

    debugTargets(){
        for( const i of this.items.values() ){
            Debug.pnt.add( i.target.pos, 0x00ff00, 2 );
        }
    }

    runSolvers(){
        const ri = this.items.get( 'arm_l' );

        ri.solver( ri.target, ri.chain, this.pose );

        this.pose.updateWorld();
    }

    iter(){ return this.items.values(); }
}

class IKSet{
    constructor( bc, solver ){
        this.chain  = ( bc instanceof IKChain )? bc : new IKChain( bc );
        this.solver = solver;
        this.target = new IKTarget();
    }

    updatePose( pose ){ this.solver( this.target, ri.chain, pose ); }
}

class IKRig{
    sets      = {};
    arm       = null;
    pose      = null;
    executor  = null;

    constructor( arm ){
        this.pose = arm.newPose();
    }

    addSet( name, bc, solver ){
        const ik = new IKSet( bc, solver );
        this.sets[ name ] = ik;
        return ik;
    }

    // Maybe call it updatePose?
    updatePose(){ this.executor( this ); return this; }
}


class BipedalRig{
    static create( arm ){
        const bMap = new BoneMap( arm );
        const rig  = new IKRig();
        rig.executor = BipedalIKRig.executor;

        rig.addSet( 'lArm', bMap.getBones( ['upperarm_l','forearm_l'] ), limbSolver );

        return rig;
    }

    static executor( rig ){
        rig.sets.lArm.updatePose( rig.pose );
        this.pose.updateWorld();
    }
}


//#endregion
</script></body></html>